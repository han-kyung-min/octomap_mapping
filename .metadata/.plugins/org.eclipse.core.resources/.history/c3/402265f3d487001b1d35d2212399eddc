/*
 * FrontierDetector.cpp
 *
 *  Created on: Mar 18, 2021
 *      Author: hankm
 */


#include "../include/FrontierDetector.hpp"

namespace frontier_detector
{

FrontierDetector::FrontierDetector(const ros::NodeHandle private_nh_, const ros::NodeHandle &nh_):

m_nh_private(private_nh_),
m_nh(nh_)
{
	m_morph_kernel = cv::getStructuringElement( cv::MORPH_RECT, cv::Size(3,3) );
	m_mapframedataSub = m_nh.subscribe("mapframe_data", 1, &FrontierDetector::mapCallback, this); // kmHan
}

FrontierDetector::~FrontierDetector()
{

}


//gridValue function
int FrontierDetector::gridValue(nav_msgs::OccupancyGrid &mapData,std::vector<float> Xp)
{
	float resolution=mapData.info.resolution;
	float Xstartx=mapData.info.origin.position.x;
	float Xstarty=mapData.info.origin.position.y;

	float width=mapData.info.width;
	std::vector<signed char> Data=mapData.data;

	//returns grid value at "Xp" location
	//map data:  100 occupied      -1 unknown       0 free
	float indx=(  floor((Xp[1]-Xstarty)/resolution)*width)+( floor((Xp[0]-Xstartx)/resolution) );
//ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
//ROS_WARN("-- grid idx map size: %d %d \n", indx, Data.size() );

	int out;
	out=Data[int(indx)];
//ROS_WARN("out: %d", out);
	return out;
}



// ObstacleFree function-------------------------------------

char FrontierDetector::ObstacleFree(std::vector<float> xnear, std::vector<float> &xnew, nav_msgs::OccupancyGrid mapsub)
{
	float rez=float(mapsub.info.resolution)*.2;
	float stepz= static_cast<float>(  static_cast<float>(ceil(Norm(xnew,xnear)))/rez  ); //int(ceil(Norm(xnew,xnear))/rez); by kmHan
	std::vector<float> xi=xnear;
	char  obs=0; char unk=0;

	ROS_ERROR("xnear %f %f  xnew %f %f \n", xnear[0], xnear[1], xnew[0], xnew[1] ) ;
	ROS_ERROR("resolution: %f rez: %f  stepz: %f", mapsub.info.resolution, rez, stepz) ;

	geometry_msgs::Point p;
	//for (int c=0;c<stepz;c++)		// <<=== The purpose of this for-loop is ? (by kmHan)
	{
//ROS_WARN("- xnear: %f %f xnew: %f %f \n", xnear[0], xnear[1], xnew[0], xnew[1]);
//ROS_WARN("resolution %f rez: %f \n", mapsub.info.resolution, rez);

		xi=Steer(xi,xnew,rez);
		int gridval = gridValue(mapsub,xi) ;

		if(gridval == 100) {obs=1;}	// 100 occupied
		else if(gridval == -1)		//  -1 unknown
		{
			unk=1;
		}
//		if (gridValue(mapsub,xi) ==100){     obs=1; }
//		if (gridValue(mapsub,xi) ==-1){      unk=1;	break;}
	}

	char out=0;
	 xnew=xi;
	 if (unk==1){  out=-1;}		// unknown

	 if (obs==1){  out=0;}		// occupied

	 if (obs!=1 && unk!=1){   out=1;} // free

	 return out;

 }


void FrontierDetector::mapCallback(const octomap_server::mapframedata& msg )
{
	cv_bridge::CvImagePtr cv_ptr;
	cv_ptr = cv_bridge::toCvCopy( msg.image_map_2d, sensor_msgs::image_encodings::MONO8 );

	cv::Mat img, img_edge, img_occ_only, img_occ_dilate, img_non_occ_dialate, img_frontiers ;
	img = cv_ptr->image.clone() ;

//	for(int rowidx =0; rowidx < img.rows; rowidx++)
//	{
//		for(int colidx=0; colidx < img.cols; colidx++)
//		{
//			if( img.at<uchar>(rowidx,colidx) >= 200 )
//				ROS_WARN(" %u ", img.at<uchar>(rowidx,colidx) );
//		}
//		ROS_WARN("\n");
//	}

//	ROS_WARN("img type: %d \n", img.type());  // uint8

	// edge
	img_edge = img.clone();
	cv::Canny(img, img_edge, 0, 255, 3);

	// obstacles , walls
	cv::threshold(img, img_occ_only, OCCUPIED_BIN_THR, 255, cv::THRESH_BINARY);

	// dialate
	//cv::morphologyEx(img_occ_only, , op, kernel, anchor, iterations, borderType, borderValue)
	cv::dilate(img_occ_only, img_occ_dilate, m_morph_kernel);

	// inverse image
	cv::threshold( img_occ_dilate, img_non_occ_dialate, 1, 255, CV_THRESH_BINARY_INV);
	img_frontiers = img_edge.mul( img_non_occ_dialate );
	//cv::erode(img_frontiers, img_frontiers, m_morph_kernel);

	cv::namedWindow("frontier_detector", 1);
	cv::namedWindow("edge",1);
	cv::namedWindow("threshold", 1);
	cv::namedWindow("dilate", 1);
	cv::namedWindow("frontiers", 1);

	cv::imshow("frontier_detector", img);
	cv::imshow("edge",img_edge);
	cv::imshow("threshold", img_occ_only);
	cv::imshow("dilate", img_occ_dilate);
	cv::imshow("frontiers", img_frontiers);

	cv::waitKey(10);

	return ;
}


}

