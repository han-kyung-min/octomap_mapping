/*
 * FrontierDetector.cpp
 *
 *  Created on: Mar 18, 2021
 *      Author: hankm
 */


#include "../include/FrontierDetector.hpp"

namespace frontier_detector
{

FrontierDetector::FrontierDetector(const ros::NodeHandle private_nh_, const ros::NodeHandle &nh_):

m_nh_private(private_nh_),
m_nh(nh_),
m_worldFrameId("world"), m_baseFrameId("base_link_gt"),
m_globalcostmap_rows(0), m_globalcostmap_cols(0), m_bIsRobotMoving(false),
m_move_client("move_base", true)
{

	m_nh.param("octomap_server/gridmap/num_downsamples", m_nNumPyrDownSample,1); // slide !!
	//ros::param::param("/tesse0/octomap_server/gridmap/num_downsamples", m_nNumPyrDownSample,1);
	m_nScale = pow(2, m_nNumPyrDownSample);
	//m_morph_kernel = cv::getStructuringElement( cv::MORPH_RECT, cv::Size(3,3) );
	m_targetspub = m_nh.advertise<geometry_msgs::PointStamped>("detected_points", 10);
	m_currentgoalpub = m_nh.advertise<geometry_msgs::PoseWithCovarianceStamped>("curr_goalpose", 10);
	m_markercandpub = m_nh.advertise<visualization_msgs::Marker>("detected_shapes", 10);
	m_markerfrontierpub = m_nh.advertise<visualization_msgs::Marker>("filtered_shapes", 10);


	//---------------------------------------------------------------
	m_mapsub = m_nh.subscribe("projected_map", 1, &FrontierDetector::gridmapCallBack, this);
	m_mapframedataSub  	= m_nh.subscribe("mapframe_data", 1, &FrontierDetector::mapdataCallback, this); // kmHan
	//m_globalplanSub 	= m_nh.subscribe("move_base_node/NavfnROS/plan",1 , &FrontierDetector::moveRobotCallback, this) ; // kmHan
	m_globalplanSub 	= m_nh.subscribe("curr_goalpose",1 , &FrontierDetector::moveRobotCallback, this) ; // kmHan
	m_globalCostmapSub 	= m_nh.subscribe("move_base_node/global_costmap/costmap", 1, &FrontierDetector::globalCostmapCallBack, this );
	m_poseSub		   	= m_nh.subscribe("pose", 10, &FrontierDetector::robotPoseCallBack, this);

	m_makeplan_client = m_nh.serviceClient<nav_msgs::GetPlan>("move_base_node/make_plan");

	while(!m_move_client.waitForServer(ros::Duration(5.0)))
	{
		ROS_INFO("Waiting for the move_base action server to come up");
	}
	ROS_WARN("move_base action server is up");


	m_frontiers_region_thr = (WEAK_COMPONENT_THR) / m_nScale ;

	m_cands.header.frame_id= m_worldFrameId;
	m_cands.header.stamp=ros::Time(0);
	m_cands.ns= "markers";
	m_cands.id = 0;
	m_cands.type = m_points.POINTS;

	m_cands.action = m_cands.ADD;
	m_cands.pose.orientation.w =1.0;
	m_cands.scale.x=0.3;
	m_cands.scale.y=0.3;

	m_cands.color.r = 255.0/255.0;
	m_cands.color.g = 0.0/255.0;
	m_cands.color.b = 0.0/255.0;
	m_cands.color.a=1.0;
	m_cands.lifetime = ros::Duration();

	m_points.header.frame_id= m_worldFrameId;
	m_points.header.stamp=ros::Time(0);
	m_points.ns= "markers";
	m_points.id = 0;
	m_points.type = m_cands.POINTS;

	//Set the marker action.  Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)
	m_points.action = m_points.ADD;
	m_points.pose.orientation.w =1.0;
	m_points.scale.x=0.3;
	m_points.scale.y=0.3;

	m_points.color.r = 0.0/255.0;
	m_points.color.g = 255.0/255.0;
	m_points.color.b = 0.0/255.0;
	m_points.color.a=1.0;
	m_points.lifetime = ros::Duration();

}

FrontierDetector::~FrontierDetector()
{

}

//Norm function
float FrontierDetector::Norm(cv::Point2f x1, cv::Point2f x2)
{
	return pow(	(pow((x2.x-x1.x),2)+pow((x2.y-x1.y),2))	,0.5);
}

cv::Point2f FrontierDetector::img2grimap( cv::Point img_pt  )
{
	float fResolution=m_gridmap.info.resolution;
	float fXstart =m_gridmap.info.origin.position.x  ;
	float fYstart =m_gridmap.info.origin.position.y  ;

	float fpx = static_cast<float>(img_pt.x) - 466/2 - 45 ;
	float fpy = static_cast<float>(img_pt.y) - 528/2 ; //- 20 ;

//	ROS_WARN("%f %f %f %d %d\n", fpx, fResolution, fXstart, m_nScale, m_nNumPyrDownSample );
//	ROS_WARN("%f %f %f %d \n", fpy, fResolution, fYstart, m_nScale );
	float fgx = ( fpx * fResolution ); // + fXstart ) ;
	float fgy = ( fpy * fResolution ); // - fYstart ) ;

	return cv::Point2f( fgx, fgy );
}

cv::Point FrontierDetector::gridmap2img( cv::Point2f grid_pt)
{
	float fResolution=m_gridmap.info.resolution;
	float fXstart =m_gridmap.info.origin.position.x  ;
	float fYstart =m_gridmap.info.origin.position.y  ;

	float fx = grid_pt.x / fResolution + 466/2 + 45 ;
	float fy = grid_pt.y / fResolution + 528/2 ;

	int nx = static_cast<int>( fx ); // + fXstart ) ;
	int ny = static_cast<int>( fy ); // - fYstart ) ;

	return cv::Point2f( nx, ny );
}

//gridValue function
int8_t FrontierDetector::gridValue(nav_msgs::OccupancyGrid &mapData, cv::Point2f Xp)
{
// Please make sure that Xp is not a downsampled point !!!!

	float resolution=mapData.info.resolution;
	float Xstartx=mapData.info.origin.position.x;
	float Xstarty=mapData.info.origin.position.y;
	float width=mapData.info.width;

	ROS_WARN("costmap info: %f %f %f %f \n", resolution, Xstartx, Xstarty, width);

	std::vector<signed char> Data=mapData.data;

	//returns grid value at "Xp" location
	//map data:  100 occupied      -1 unknown       0 free
	float indx=(  floor((Xp.y-Xstarty)/resolution)*width)+( floor((Xp.x-Xstartx)/resolution) );
	int nIdx = static_cast<int>(indx) ;
ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
ROS_WARN("-- grid idx map size: %d %d \n", nIdx, Data.size() );

	int8_t out;
	out=Data[nIdx];
ROS_WARN("out: %d", out);
	return out;
}
//
//int  FrontierDetector::computeRevenue( nav_msgs::OccupancyGrid &mapData, cv::Point2f Xp, int winsize = 25 )
//{
//	float Xstartx=mapData.info.origin.position.x; // world coordinate in the costmap
//	float Xstarty=mapData.info.origin.position.y; // world coordinate in the costmap
//	float resolution = mapData.info.resolution ;
//
//	int width= static_cast<uint32_t>(mapData.info.width) ;
//	std::vector<signed char> Data=mapData.data;
//
//	//returns grid value at "Xp" location
//	//map data:  100 occupied      -1 unknown       0 free
//	int px= floor((Xp.y-Xstarty)/resolution) ;
//	int py= floor((Xp.x-Xstartx)/resolution) ;
//	int8_t cost ;
//	uint32_t rev = 0;
//
//	for( int ridx =-winsize; ridx < winsize; ridx++)
//	{
//		for( int cidx=-winsize; cidx < winsize; cidx++)
//		{
//			int idx = px + cidx + (py + ridx) * width ;
//			cost = Data(idx) ;
//			if(cost <= 0)
//				rev++ ;
//		}
//	}
//
////ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
////ROS_WARN("-- grid idx map size: %d %d \n", indx, Data.size() );
//
//	int out;
//	out=Data[int(indx)];
////ROS_WARN("out: %d", out);
//	return out;
//}


//int  FrontierDetector::costmapValue( nav_msgs::OccupancyGrid &mapData, cv::Point2f Xp )
//{
//	float Xstartx=mapData.info.origin.position.x; // world coordinate in the costmap
//	float Xstarty=mapData.info.origin.position.y; // world coordinate in the costmap
//	float resolution = mapData.info.resolution ;
//
//	float width=mapData.info.width;
//	std::vector<signed char> Data=mapData.data;
//
//	//returns grid value at "Xp" location
//	//map data:  100 occupied      -1 unknown       0 free
//	int px= floor((Xp.y-Xstarty)/resolution) ;
//	int py= floor((Xp.x-Xstartx)/resolution) ;
////ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
////ROS_WARN("-- grid idx map size: %d %d \n", indx, Data.size() );
//
//	int out;
//	out=Data[int(indx)];
////ROS_WARN("out: %d", out);
//	return out;
//}


// ObstacleFree function-------------------------------------
//
//char FrontierDetector::ObstacleFree(cv::Point2f xnear, cv::Point2f &xnew, nav_msgs::OccupancyGrid mapsub)
//{
//	float rez=float(mapsub.info.resolution)*.2;
//	float stepz= static_cast<float>(  static_cast<float>(ceil(Norm(xnew,xnear)))/rez  ); //int(ceil(Norm(xnew,xnear))/rez); by kmHan
//
//	char  obs=0; char unk=0;
//
//	ROS_ERROR("resolution: %f rez: %f  stepz: %f", mapsub.info.resolution, rez, stepz) ;
//
//	geometry_msgs::Point p;
//	//for (int c=0;c<stepz;c++)		// <<=== The purpose of this for-loop is ? (by kmHan)
//	{
////ROS_WARN("- xnear: %f %f xnew: %f %f \n", xnear[0], xnear[1], xnew[0], xnew[1]);
////ROS_WARN("resolution %f rez: %f \n", mapsub.info.resolution, rez);
//
//		int gridval = gridValue(mapsub,xnew) ;
//
//		if(gridval == 100) {obs=1;}	// 100 occupied
//		else if(gridval == -1)		//  -1 unknown
//		{
//			unk=1;
//		}
////		if (gridValue(mapsub,xi) ==100){     obs=1; }
////		if (gridValue(mapsub,xi) ==-1){      unk=1;	break;}
//	}
//
//	char out=0;
//	 //xnew=xi;
//
//	 if (unk==1){  out=-1;}		// unknown
//
//	 if (obs==1){  out=0;}		// occupied
//
//	 if (obs!=1 && unk!=1){   out=1;} // free
//
//	 return out;
//
// }
//


vector<cv::Point> FrontierDetector::eliminateSupriousFrontiers( nav_msgs::OccupancyGrid &costmapData, vector<cv::Point> frontierCandidates, int winsize)
{
	ROS_WARN("eliminating suprious frontiers \n");
	ROS_WARN("in func width: %d %d %f\n", m_globalcostmap.info.width, m_globalcostmap_cols, m_globalcostmap.info.resolution);

	vector<cv::Point> outFrontiers ;

	float fXstartx=costmapData.info.origin.position.x; // world coordinate in the costmap
	float fXstarty=costmapData.info.origin.position.y; // world coordinate in the costmap
	float resolution = costmapData.info.resolution ;

	int width= static_cast<int>(costmapData.info.width) ;
	std::vector<signed char> Data=costmapData.data;

	for( size_t idx =0; idx < frontierCandidates.size(); idx++) // frontiers in image coord
	{
		cv::Point2f frontier_in_Gridmap = img2grimap( frontierCandidates[idx] * m_nScale );
		//returns grid value at "Xp" location
		//map data:  100 occupied      -1 unknown       0 free
		int py_c= floor( (frontier_in_Gridmap.y - fXstarty ) / resolution  ) ; // px in costmap
		int px_c= floor( (frontier_in_Gridmap.x - fXstartx ) / resolution  ) ;
		int8_t cost ;
		float fcost = 0;

		//ROS_WARN(" idx px py %u %d %d\n", idx, px_c, py_c);
		cv::Mat roi = cv::Mat::zeros(winsize*2, winsize*2, CV_8U);
		for( int ridx =-winsize; ridx < winsize; ridx++)
		{
			for( int cidx=-winsize; cidx < winsize; cidx++)
			{
				int idx = px_c + cidx + (py_c + ridx) * width ;
				//ROS_WARN("ind rix cidx %d %d %d ", idx, ridx, cidx);
				cost = Data[idx] ;
				fcost = fcost + static_cast<float>(cost) ;
				if(cost <= 0)
				{
					//rev = rev + 1.f ;
					//roi.at<uint8_t>(ridx+winsize, cidx+winsize) = 0;
				}
				else
				{
					//roi.at<uint8_t>(ridx+winsize, cidx+winsize) = cost;
				}
			}
		}
//		const string name = "/home/hankm/catkin_ws/src/frontier_detector/images/roi/frontier_patch_" + std::to_string(idx) + ".png" ;
//		cv::imwrite(name,  roi) ;
		ROS_WARN("fcost: %f / %d  \n", fcost,  (winsize*2)*(winsize*2) ) ;
		fcost = fcost / static_cast<float>( (winsize*2) * (winsize*2) ) ;
		if( fcost < 40  ) // 0 ~ 100
		{
			// move back to image coord
			//ROS_WARN("pts in cost map:  (%d  %d) in gridmap (%f %f) frontierCandidates: (%d  %d) res: %f  sx sy (%f %f)\n",
//					px_c, py_c, frontier_in_Gridmap.x, frontier_in_Gridmap.y, frontierCandidates[idx].x, frontierCandidates[idx].y,
//					resolution, fXstartx, fXstarty ) ;

			cv::Point frontier_in_img = gridmap2img( frontier_in_Gridmap ) ;
//ROS_WARN("in gridmap: %d %d in image: %f %f\n", frontier_in_Gridmap.x, frontier_in_Gridmap.y, frontier_in_img.x/m_nScale, frontier_in_img.y/m_nScale );
			outFrontiers.push_back( cv::Point(frontier_in_img.x / m_nScale, frontier_in_img.y / m_nScale)  );
		}
	}

	return outFrontiers ;  // in image coord frame
}

//
//vector<FrontierInfo> FrontierDetector::assessFrontiers( vector<cv::Point> frontierCandidates )
//{
//	ROS_WARN("here 1 \n");
//	ROS_WARN("in func width: %d %d %f\n", m_globalcostmap.info.width, m_globalcostmap_cols, m_globalcostmap.info.resolution);
//
//	vector<cv::Point> outFrontiers  ;
//	int nRowOffset = m_globalcostmap_rows/2 ;
//	int nColOffset = m_globalcostmap_cols/2 ;
//
//	ROS_WARN("here 2 \n");
//	for( size_t i=0; i <= frontierCandidates.size(); i++ )
//	{
//		int u_ = frontierCandidates[i].x + nColOffset ;
//		int v_ = frontierCandidates[i].y + nRowOffset ;
//
//		ROS_WARN("u_ v_ : %d %d \n", u_, v_);
//		// create an image patch (50 x 50 ),  then update pixels
//		cv::Mat roi = cv::Mat::zeros(50, 50, CV_8S);
//		int x = 0;
//		int y = 0;
//
//		ROS_WARN("here 3 \n");
//		for( int ridx= v_ - 25; ridx < v_ + 25; v_++)
//		{
//			for( int cidx = u_ - 25; cidx < u_ + 25; u_++ )
//			{
//				ROS_WARN("here 4 \n");
//				int8_t value = gridValue( m_globalcostmap,  cv::Point( cidx, ridx )  );
//				ROS_WARN("here 5 \n");
//				roi.at<int8_t>(x,y) = value ;
//				x++;
//				ROS_WARN("roi: %d %d \n", x, y);
//			}
//			y++;
//		}
//		const string name = "/home/hankm/catkin_ws/src/frontier_detector/images/roi/frontier_patch_" + std::to_string(i) + ".png" ;
//		cv::imwrite(name,  roi) ;
//	}
//
//	ROS_WARN("here 2 \n");
//	//return outFrontiers ;
//}
//

//cv::Point FrontierDetector::estimateFrontierPointPose( vector<cv::Point> frontier_contour, cv::Point frontier_point );
//{
//
//}


geometry_msgs::PoseStamped FrontierDetector::StampedPosefromSE2( float x, float y, float yaw_radian )
{
	geometry_msgs::PoseStamped outPose ;
	outPose.pose.position.x = x ;
	outPose.pose.position.y = y ;

	float c[3] = {0,};
	float s[3] = {0,};
	c[0] = cos(yaw_radian/2) ;
	c[1] = cos(0) ;
	c[2] = cos(0) ;
	s[0] = sin(yaw_radian/2) ;
	s[1] = sin(0) ;
	s[2] = sin(0) ;

	float qout[4] = {0,};
	qout[0] = c[0]*c[1]*c[2] + s[0]*s[1]*s[2];
	qout[1] = c[0]*c[1]*s[2] - s[0]*s[1]*c[2];
	qout[2] = c[0]*s[1]*c[2] + s[0]*c[1]*s[2];
	qout[3] = s[0]*c[1]*c[2] - c[0]*s[1]*s[2];

	outPose.pose.orientation.w = qout[0] ;
	outPose.pose.orientation.x = qout[1] ;
	outPose.pose.orientation.y = qout[2] ;
	outPose.pose.orientation.z = qout[3] ;

	outPose.header.frame_id = m_worldFrameId ;
	outPose.header.stamp = ros::Time::now() ;

	return outPose;
}

geometry_msgs::PoseStamped FrontierDetector::GetCurrPose ( )
{
	geometry_msgs::PoseStamped outPose ;
	outPose.header = m_robotpose.header ;
	outPose.pose.position.x = m_robotpose.pose.pose.position.x ;
	outPose.pose.position.y = m_robotpose.pose.pose.position.y ;
	outPose.pose.position.z = 0.f ;

	outPose.pose.orientation = m_robotpose.pose.pose.orientation ;

	return outPose;
}


void FrontierDetector::globalCostmapCallBack(const nav_msgs::OccupancyGrid::ConstPtr& msg)
{
	m_globalcostmap = *msg ;
	m_globalcostmap_rows = m_globalcostmap.info.height ;
	m_globalcostmap_cols = m_globalcostmap.info.width ;
}

void FrontierDetector::gridmapCallBack(const nav_msgs::OccupancyGrid::ConstPtr& msg)
{
	m_gridmap = *msg ;
}

void FrontierDetector::robotPoseCallBack( const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg )
{
	m_robotpose = *msg ;
	//ROS_WARN("callback pose:  %f %f \n", m_robotpose.pose.pose.position.x, m_robotpose.pose.pose.position.y);
}

void FrontierDetector::doneCB( const actionlib::SimpleClientGoalState& state )
{
    ROS_WARN("DONECB: Finished in state [%s]", state.toString().c_str());
    if (m_move_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
    {
         // do something as goal was reached
    }
    if (m_move_client.getState() == actionlib::SimpleClientGoalState::ABORTED)
    {
        // do something as goal was canceled
    }
}

void FrontierDetector::mapdataCallback(const octomap_server::mapframedata& msg )
{
	cv_bridge::CvImagePtr cv_ptr;
	cv_ptr = cv_bridge::toCvCopy( msg.image_map_2d, sensor_msgs::image_encodings::MONO8 );

	cv::Mat img ;
	img = cv_ptr->image.clone() ;

	ffpcv::FrontPropagation oFP(img); // image uchar

	oFP.update(img, cv::Point(0,0));

	oFP.extractFrontierRegion( img ) ;

	cv::Mat img_frontiers = oFP.GetFrontierContour() ;

///////////////////////////////////////////////////////////////////////////////////////////////
//  connected componentWithStat
//	stat 	--> 5 col matrix where [0],[1],[2],[3] are x, y, width, and height. [4] is the size (number of pixels)
//	centroid--> 2 col matrix where [0],[1] are the centroids (x and y coordinates)
///////////////////////////////////////////////////////////////////////////////////////////////

//	cv::Mat labelImage(img.size(), CV_32S);
//	cv::Mat stats, centroids;
//	int nLabels = cv::connectedComponentsWithStats(img_frontiers, labelImage, stats, centroids, 8);
//	std::vector<cv::Vec3b> colors(nLabels);

//    colors[0] = cv::Vec3b(0, 0, 0);//background
//    for(int label = 1; label < nLabels; ++label){
//        colors[label] = cv::Vec3b( (rand()&255), (rand()&255), (rand()&255) );
//    }
//    cv::Mat dst(img.size(), CV_8UC3);
//    for(int r = 0; r < dst.rows; ++r){
//        for(int c = 0; c < dst.cols; ++c){
//            int label = labelImage.at<int>(r, c);
//            cv::Vec3b &pixel = dst.at<cv::Vec3b>(r, c);
//            pixel = colors[label];
//         }
//     }

	cv::Mat dst;
	cvtColor(img_frontiers, dst, cv::COLOR_GRAY2BGR);
//    for(int i = 1; i < nLabels; ++i)
//    {
//        int* label = stats.ptr<int>(i);
//        if(label[4] < WEAK_COMPONENT_THR) continue;
//
//        cv::rectangle(dst, cv::Rect(label[0], label[1], label[2], label[3]), cv::Scalar(0,255,255));
//    }

// locate the most closest labeled points w.r.t the centroid pts

	vector<vector<cv::Point> > contours;
	vector<cv::Vec4i> hierarchy;
	cv::findContours( img_frontiers, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );

	// iterate through all the top-level contours,
	// draw each connected component with its own random color
	int idx = 0;
	for( ; idx >= 0; idx = hierarchy[idx][0] )
	{
		cv::Scalar color( rand()&255, rand()&255, rand()&255 );
		drawContours( dst, contours, idx, color, CV_FILLED, 8, hierarchy );
	}

	/// Get the moments
//    vector<cv::Moments> mu(contours.size() );
//    for( int i = 0; i < contours.size(); i++ )
//    	mu[i] = moments( contours[i], false );
//
//    // get cent
//    vector<cv::Point2f> mc( contours.size() );
//    for( int i = 0; i < contours.size(); i++ )
//    	mc[i] = cv::Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );

	vector<cv::Point2f> fcents;
	for(int i=0; i < contours.size(); i++)
	{
		float fx =0, fy =0 ;
		float fcnt = 0 ;
		vector<cv::Point> contour = contours[i];
		for( int j=0; j < contour.size(); j++)
		{
			fx += static_cast<float>( contour[j].x ) ;
			fy += static_cast<float>( contour[j].y ) ;
			fcnt += 1.0;
		}
		fx = fx/fcnt ;
		fy = fy/fcnt ;

		cv::Point2f fcent( fx,  fy ) ;
		fcents.push_back(fcent);
	}

	// get closest frontier pt to each cent
	// i.e.) the final estimated frontier points
	vector<cv::Point> frontiers_cand;
	//ROS_ERROR("thr %d  \n", m_frontiers_region_thr);
	for( int i = 0; i < contours.size(); i++ )
	{
		vector<cv::Point> contour = contours[i] ;

		if(contour.size() < m_frontiers_region_thr ) // don't care about small frontier regions
			continue ;

		float fcentx = fcents[i].x ;
		float fcenty = fcents[i].y ;

		float fmindist = 1000 ;
		int nmindistidx = -1;

		for (int j=0; j < contour.size(); j++)
		{
			float fx = static_cast<float>(contour[j].x) ;
			float fy = static_cast<float>(contour[j].y) ;
			float fdist = std::sqrt( (fx - fcentx) * (fx - fcentx) + (fy - fcenty) * (fy - fcenty) );
			if(fdist < fmindist)
			{
				fmindist = fdist ;
				nmindistidx = j ;
			}
		}

		assert(nmindistidx >= 0);
		cv::Point frontier = contour[nmindistidx];
		frontiers_cand.push_back(frontier) ;
	}

//	ROS_WARN("msg: %d \n", m_globalcostmap.info.width );

	geometry_msgs::Point p;
	m_cands.points.clear();
	m_exploration_goal.clear();
	m_points.points.clear();

	//
	vector<cv::Point> frontier_cand_in_gridmap ;
	for(size_t idx=0; idx < frontiers_cand.size(); idx++)
	{
		cv::Point2f frontier_in_Gridmap = img2grimap( frontiers_cand[idx] * m_nScale );
		frontier_cand_in_gridmap.push_back( frontier_in_Gridmap );
		p.x = frontier_in_Gridmap.x ;
		p.y = frontier_in_Gridmap.y ;
		p.z = 0.0 ;
		m_cands.points.push_back(p);
	}
	m_markercandpub.publish(m_cands);

	// eliminate frontier points at obtacles
	vector<cv::Point> frontiers;
	if( m_globalcostmap.info.width > 0 )
	{
		frontiers = eliminateSupriousFrontiers( m_globalcostmap, frontiers_cand, 20) ;
	}
	else
	{
		frontiers = frontiers_cand ; // points in img coord
	}

	if( frontiers.empty() )
	{
		ROS_ERROR("no valid frontiers \n");
		return;
	}

//	if(m_globalcostmap.info.width > 0 &&  m_globalcostmap.info.height > 0 )
//		assessFrontiers( frontiers );

	// set exploration goals
	ROS_WARN("========================================================================== \n" );
	for(int idx=0; idx < frontiers.size(); idx++)
	{
		cv::Point frontier = frontiers[idx] ;
//		ROS_ERROR("cent: %d %d \n",frontier.x,frontier.y);
		cv::circle(dst, frontier, 3, CV_RGB(255,0,0), 2);

		// scale then conv 2 gridmap coord
		cv::Point2f frontier_in_Gridmap = img2grimap( frontier * m_nScale );
		geometry_msgs::PoseWithCovarianceStamped mygoal ; // float64
		mygoal.header.stamp=ros::Time(0);
		mygoal.header.frame_id = m_worldFrameId;
		mygoal.pose.pose.position.x= frontier_in_Gridmap.x ;
		mygoal.pose.pose.position.y= frontier_in_Gridmap.y ;
		mygoal.pose.pose.position.z=0.0;
		m_exploration_goal.push_back(mygoal) ;

		m_targetspub.publish(mygoal);
		p.x = mygoal.pose.pose.position.x ;
		p.y = mygoal.pose.pose.position.y ;
		p.z = 0.0 ;
		m_points.points.push_back(p);

		ROS_WARN("frontier in img: (%d %d) in point: (%f %f) scale: %d\n",
				frontier.x, frontier.y, p.x, p.y, m_nScale );
	}
	ROS_WARN("========================================================================== \n" );
	// publish the "to be exploration goals" (detected points)

	std::random_shuffle(m_points.points.begin(), m_points.points.end());

	float resolution=m_globalcostmap.info.resolution;
	float Xstartx=m_globalcostmap.info.origin.position.x;
	float Xstarty=m_globalcostmap.info.origin.position.y;
	float width=m_globalcostmap.info.width;

	//ROS_WARN("costmap info: %f %f %f %f \n", resolution, Xstartx, Xstarty, width);
	//ROS_WARN("frontier: %f %f \n", m_points.points[0].x, m_points.points[0].y );

// generate a path trajectory
// call make plan service
	p = m_points.points[0];  // just for now... we need to fix it later
	nav_msgs::GetPlan::Request req;
	nav_msgs::GetPlan::Response res ;

	req.start = GetCurrPose( );
	req.goal  = StampedPosefromSE2( p.x, p.y, 0.f );
	req.goal.header.frame_id = m_worldFrameId ;

	if(!m_bIsRobotMoving)
	{
		ROS_WARN("establishing a new plan from (%f %f) to (%f %f)\n"
				,req.start.pose.position.x, req.start.pose.position.y,
				req.goal.pose.position.x, req.goal.pose.position.y);
		m_makeplan_client.call( req, res );
		m_bIsRobotMoving = true ;
	}
	m_markerfrontierpub.publish(m_points);


	// publish current goal of the path plan
	geometry_msgs::PoseWithCovarianceStamped currgoal = m_exploration_goal[0] ;
	m_currentgoalpub.publish(currgoal);

// call actionlib
	//ROS_WARN("I am here \n");

	move_base_msgs::MoveBaseGoal goal;
	goal.target_pose.header.frame_id = m_worldFrameId; //m_baseFrameId ;
	goal.target_pose.header.stamp = ros::Time::now() ;

	goal.target_pose.pose.position.x = req.goal.pose.position.x ;
	goal.target_pose.pose.position.y = req.goal.pose.position.y ;
	goal.target_pose.pose.orientation.w = req.goal.pose.orientation.w ;


////	m_bIsRobotMoving = true;
////	if(m_bIsRobotMoving)
////	{
//
//
//// inspect the path
////	ROS_WARN("printing path for start(%f %f) to goal(%f %f): \n",
////			req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y );
////	for(size_t i=0; i < res.plan.poses.size(); i++)
////	{
////		ROS_WARN("goal: %f %f \n", res.plan.poses[0].pose.position.x, res.plan.poses[0].pose.position.y);
////	}
//

//	m_move_client.sendGoal(goal, boost::bind(&FrontierDetector::doneCB, this, _1), MoveBaseClient::SimpleActiveCallback() ) ;
//	m_move_client.waitForResult();


//	while(m_bIsRobotMoving)
//	{
//		cv::namedWindow("frontier");
//		cv::namedWindow("map");
//
//		cv::imshow("map", img);
//		cv::imshow("frontier",dst);
//
//		cv::waitKey(10);
//	}

//	cv::namedWindow("frontier");
//	cv::namedWindow("map");
//
//	cv::imshow("map", img);
//	cv::imshow("frontier",dst);
//
//	cv::waitKey(10);
//
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/map.png", img);
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_points.png", dst);
}

void FrontierDetector::moveRobotCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg )
{

// call actionlib
	geometry_msgs::PoseWithCovarianceStamped goalpose = *msg ;

	ROS_WARN("A plan received \n");

	move_base_msgs::MoveBaseGoal goal;
	goal.target_pose.header.frame_id = m_worldFrameId; //m_baseFrameId ;
	goal.target_pose.header.stamp = ros::Time::now() ;

//	geometry_msgs::PoseWithCovarianceStamped goalpose = // m_pathplan.poses.back() ;

	goal.target_pose.pose.position.x = goalpose.pose.pose.position.x ;
	goal.target_pose.pose.position.y = goalpose.pose.pose.position.y ;
	goal.target_pose.pose.orientation.w = goalpose.pose.pose.orientation.w ;

// inspect the path
//	ROS_WARN("printing path for start(%f %f) to goal(%f %f): \n",
//			req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y );

	ROS_WARN("goal pose: %f %f %f\n", goalpose.pose.pose.position.x, goalpose.pose.pose.position.y, goalpose.pose.pose.orientation.w);

	m_move_client.sendGoal(goal, boost::bind(&FrontierDetector::doneCB, this, _1), MoveBaseClient::SimpleActiveCallback() ) ;
	m_move_client.waitForResult();
	m_bIsRobotMoving = false ;

	ROS_WARN("goal reached \n");

//	while(m_bIsRobotMoving)
//	{
//		cv::namedWindow("frontier");
//		cv::namedWindow("map");
//
//		cv::imshow("map", img);
//		cv::imshow("frontier",dst);
//
//		cv::waitKey(10);
//	}

//	cv::namedWindow("frontier");
//	cv::namedWindow("map");
//
//	cv::imshow("map", img);
//	cv::imshow("frontier",dst);
//
//	cv::waitKey(10);
//
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/map.png", img);
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_points.png", dst);
}


//void FrontierDetector::mapdataCallback(const octomap_server::mapframedata& msg )
//{
//	cv_bridge::CvImagePtr cv_ptr;
//	cv_ptr = cv_bridge::toCvCopy( msg.image_map_2d, sensor_msgs::image_encodings::MONO8 );
//
//	cv::Mat img, img_edge, img_occ_only, img_occ_dilate, img_non_occ_dialate, img_frontiers ;
//	img = cv_ptr->image.clone() ;
//
////	for(int rowidx =0; rowidx < img.rows; rowidx++)
////	{
////		for(int colidx=0; colidx < img.cols; colidx++)
////		{
////			//if( img.at<uchar>(rowidx,colidx) >= 200 )
////			ROS_WARN(" %u ", img.at<uchar>(rowidx,colidx) );
////		}
////		ROS_WARN("\n");
////	}
//
////	cv::imshow("img",img);
////	cv::waitKey(0);
//
////	ROS_WARN("img type: %d \n", img.type());  // 0 == CV_8U == uchar
//
//	// edge
//	cv::Mat imgsrc = img.clone();
//	img_edge = img.clone();
//	cv::Canny(img, img_edge, 0, 255, 3);
//	cv::threshold(img_edge, img_edge, OCCUPIED_BIN_THR, 255, cv::THRESH_BINARY);
//
//	// obstacles , walls
//	cv::threshold(img, img_occ_only, OCCUPIED_BIN_THR, 255, cv::THRESH_BINARY);
//
//	// dialate
//	//cv::morphologyEx(img_occ_only, , op, kernel, anchor, iterations, borderType, borderValue)
//	cv::dilate(img_occ_only, img_occ_dilate, m_morph_kernel, cv::Point(-1,-1),1);
//
//	// inverse image
//	cv::threshold( img_occ_dilate, img_non_occ_dialate, 1, 255, CV_THRESH_BINARY_INV);
//	img_frontiers = img_edge.mul( img_non_occ_dialate );
////	cv::erode(img_frontiers, img_frontiers, m_morph_kernel);
////	cv::dilate(img_frontiers, img_frontiers, m_morph_kernel);
//
/////////////////////////////////////////////////////////////////////////////////////////////////
////  connected componentWithStat
////	stat 	--> 5 col matrix where [0],[1],[2],[3] are x, y, width, and height. [4] is the size (number of pixels)
////	centroid--> 2 col matrix where [0],[1] are the centroids (x and y coordinates)
/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	cv::Mat labelImage(img.size(), CV_32S);
//	cv::Mat stats, centroids;
//    int nLabels = cv::connectedComponentsWithStats(img_frontiers, labelImage, stats, centroids, 8);
//    std::vector<cv::Vec3b> colors(nLabels);
////    colors[0] = cv::Vec3b(0, 0, 0);//background
////    for(int label = 1; label < nLabels; ++label){
////        colors[label] = cv::Vec3b( (rand()&255), (rand()&255), (rand()&255) );
////    }
////    cv::Mat dst(img.size(), CV_8UC3);
////    for(int r = 0; r < dst.rows; ++r){
////        for(int c = 0; c < dst.cols; ++c){
////            int label = labelImage.at<int>(r, c);
////            cv::Vec3b &pixel = dst.at<cv::Vec3b>(r, c);
////            pixel = colors[label];
////         }
////     }
//
//    cv::Mat dst;
//    cvtColor(img_frontiers, dst, cv::COLOR_GRAY2BGR);
////    for(int i = 1; i < nLabels; ++i)
////    {
////        int* label = stats.ptr<int>(i);
////        if(label[4] < WEAK_COMPONENT_THR) continue;
////
////        cv::rectangle(dst, cv::Rect(label[0], label[1], label[2], label[3]), cv::Scalar(0,255,255));
////    }
//
//// locate the most closest labeled points w.r.t the centroid pts
//
//    vector<vector<cv::Point> > contours;
//    vector<cv::Vec4i> hierarchy;
//    cv::findContours( img_frontiers, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );
//
//    // iterate through all the top-level contours,
//    // draw each connected component with its own random color
//    int idx = 0;
//    for( ; idx >= 0; idx = hierarchy[idx][0] )
//    {
//        cv::Scalar color( rand()&255, rand()&255, rand()&255 );
//        drawContours( dst, contours, idx, color, CV_FILLED, 8, hierarchy );
//    }
//
//    /// Get the moments
////    vector<cv::Moments> mu(contours.size() );
////    for( int i = 0; i < contours.size(); i++ )
////    	mu[i] = moments( contours[i], false );
////
////    // get cent
////    vector<cv::Point2f> mc( contours.size() );
////    for( int i = 0; i < contours.size(); i++ )
////    	mc[i] = cv::Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );
//
//    vector<cv::Point> cents;
//    for(int i=0; i < contours.size(); i++)
//    {
//    	float fx =0, fy =0 ;
//    	float fcnt = 0 ;
//    	vector<cv::Point> contour = contours[i];
//    	for( int j=0; j < contour.size(); j++)
//    	{
//    		fx += static_cast<float>( contour[j].x ) ;
//    		fy += static_cast<float>( contour[j].y ) ;
//    		fcnt += 1.0;
//    	}
//    	fx = fx/fcnt ;
//    	fy = fy/fcnt ;
//
//    	cv::Point cent( static_cast<int>(fx),  static_cast<int>(fy) ) ;
//    	cents.push_back(cent);
//    }
//
//    // get closest frontier pt to each cent
//    // i.e.) the final estimated frontier points
//    vector<cv::Point> frontiers;
//    //ROS_ERROR("thr %d  \n", m_frontiers_region_thr);
//	for( int i = 0; i < contours.size(); i++ )
//	{
//		vector<cv::Point> contour = contours[i] ;
//
//		if(contour.size() < m_frontiers_region_thr ) // don't care about small frontier regions
//			continue ;
//
//		float fcentx = static_cast<float>(cents[i].x) ;
//		float fcenty = static_cast<float>(cents[i].y) ;
//
//		float fmindist = 1000 ;
//		int nmindistidx = -1;
//
//		for (int j=0; j < contour.size(); j++)
//		{
//			float fx = static_cast<float>(contour[j].x) ;
//			float fy = static_cast<float>(contour[j].y) ;
//			float fdist = std::sqrt( (fx - fcentx) * (fx - fcentx) + (fy - fcenty) * (fy - fcenty) );
//			if(fdist < fmindist)
//			{
//				fmindist = fdist ;
//				nmindistidx = j ;
//			}
//		}
//
//		assert(nmindistidx >= 0);
//		cv::Point frontier = contour[nmindistidx];
//		frontiers.push_back(frontier) ;
//	}
//
//	geometry_msgs::Point p;
//	// publish detected points
//	for(int idx=0; idx < frontiers.size(); idx++)
//	{
//		cv::Point frontier = frontiers[idx] ;
////		ROS_ERROR("cent: %d %d \n",frontier.x,frontier.y);
//		cv::circle(dst, frontier, 3, CV_RGB(255,0,0), 2);
//
//		// scale then conv 2 gridmap coord
//		cv::Point2f frontier_in_Gridmap = img2grimap( frontier * m_nScale );
//
//		m_exploration_goal.header.stamp=ros::Time(0);
//		m_exploration_goal.header.frame_id = m_worldFrameId;
//		m_exploration_goal.point.x= frontier_in_Gridmap.x ;
//		m_exploration_goal.point.y= frontier_in_Gridmap.y ;
//		m_exploration_goal.point.z=0.0;
//
//		ROS_WARN("in image: %d %d in gridmap: %f %f ",
//				frontier.x*m_nScale, frontier.y*m_nScale, frontier_in_Gridmap.x, frontier_in_Gridmap.y );
//
//		m_targetspub.publish(m_exploration_goal); // detected points
//
//		p.x = m_exploration_goal.point.x ;
//		p.y = m_exploration_goal.point.y ;
//		p.z = 0.0 ;
//
//		m_points.points.push_back(p);
//	}
//
//	m_markerpub.publish(m_points);
//	m_points.points.clear();
//
////	cv::namedWindow("frontier_detector", 1);
////	cv::namedWindow("edge",1);
////	cv::namedWindow("threshold", 1);
////	cv::namedWindow("dilate", 1);
////	cv::namedWindow("frontiers", 1);
//
////	cv::imshow("img", imgsrc);
////	cv::imshow("frontier_detector", img);
////	cv::imshow("edge",img_edge);
////	cv::imshow("threshold", img_occ_only);
////	cv::imshow("dilate", img_occ_dilate);
////	cv::imshow("frontiers", img_frontiers);
//
//    imshow( "contours frontiers", dst );
//
//	cv::waitKey(10);
//
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/img.png", img);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/edge.png", img_edge);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/threshold.png", img_occ_only);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/dilate.png", img_occ_dilate);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_contours.png", img_frontiers);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_points.png", dst);
//
//	return ;
//}


}

