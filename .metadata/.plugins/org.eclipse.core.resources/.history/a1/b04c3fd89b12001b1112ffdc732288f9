/*
 * OctomapTest.cpp
 *
 *  Created on: Oct 20, 2020
 *      Author: hankm
 */



#include "OctomapTest.hpp"

using namespace octomap;

bool is_equal (double a, double b, double epsilon = 1.0e-7)
{
    return std::abs(a - b) < epsilon;
}

namespace octomap_test{

OctomapTest::OctomapTest(std::string strpath, uint32_t uSceneIdx)
:
  m_octree(NULL),
  m_res(0.05),
  m_treeDepth(0),
  m_maxTreeDepth(0),
  m_compressMap(true),
  m_str_path(strpath),
  m_uSceneIdx(uSceneIdx)
{
  double probHit, probMiss, thresMin, thresMax;
  // initialize octomap object & params
  m_octree = new OcTreeT(m_res);
  m_octree->setProbHit(0.7);
  m_octree->setProbMiss(0.4);
  m_octree->setClampingThresMin(0.12);
  m_octree->setClampingThresMax(0.97);
  //m_treeDepth = m_octree->getTreeDepth();
  //m_maxTreeDepth = m_treeDepth;

 // m_pPtCloud = new PCLPointCloud ;

  m_ifs_cellinfo.open( m_str_path + "/view" + std::to_string(m_uSceneIdx) + "/cell_info_6.txt");

  std::string strpt = m_str_path + "/view" + std::to_string(m_uSceneIdx) + "/point_xyz_6.txt";
	printf("loading ptc from \n %s \n",strpt.c_str() );

  m_ifs_ptcxyz.open(strpt);
  m_ofs_free_cellinfo.open( m_str_path + "/view" + std::to_string(m_uSceneIdx) + "/freecell_info.txt" );
  m_ofs_occ_cellinfo .open( m_str_path + "/view" + std::to_string(m_uSceneIdx) + "/occucell_info.txt" );
}

OctomapTest::~OctomapTest()
{
	//m_pPtCloud->clear();

	m_ifs_cellinfo.close() ;
	m_ifs_ptcxyz.close() ;
	m_ofs_occ_cellinfo.close() ;
	m_ofs_free_cellinfo.close() ;

  if (m_octree){
    delete m_octree;
    m_octree = NULL;
  }
}

bool OctomapTest::openFile(const std::string& filename)
{
  if (filename.length() <= 3)
    return false;

  std::string suffix = filename.substr(filename.length()-3, 3);
  if (suffix== ".bt"){
    if (!m_octree->readBinary(filename)){
      return false;
    }
  } else if (suffix == ".ot"){
    AbstractOcTree* tree = AbstractOcTree::read(filename);
    if (!tree){
      return false;
    }
    if (m_octree){
      delete m_octree;
      m_octree = NULL;
    }
    m_octree = dynamic_cast<OcTreeT*>(tree);
    if (!m_octree){
      printf("Could not read OcTree in file, currently there are no other types supported in .ot");
      return false;
    }

  } else{
    return false;
  }

  printf("Octomap file %s loaded (%zu nodes).", filename.c_str(),m_octree->size());

  m_treeDepth = m_octree->getTreeDepth();
  m_maxTreeDepth = m_treeDepth;
  m_res = m_octree->getResolution();

  double minX, minY, minZ;
  double maxX, maxY, maxZ;
  m_octree->getMetricMin(minX, minY, minZ);
  m_octree->getMetricMax(maxX, maxY, maxZ);

  m_updateBBXMin[0] = m_octree->coordToKey(minX);
  m_updateBBXMin[1] = m_octree->coordToKey(minY);
  m_updateBBXMin[2] = m_octree->coordToKey(minZ);

  m_updateBBXMax[0] = m_octree->coordToKey(maxX);
  m_updateBBXMax[1] = m_octree->coordToKey(maxY);
  m_updateBBXMax[2] = m_octree->coordToKey(maxZ);

  return true;
}

void OctomapTest::loadptc( )
{
	std::string strline;
	printf("\n loading ptc \n");
	while( std::getline(m_ifs_ptcxyz, strline) )
	{
		std::stringstream ss(strline);
		double x,y,z;
		ss >> x >> y >> z;
		PCLPoint pt(x,y,z);
		//std::cout << x << " " << y << " " << z << std::endl;
		m_PtCloud.push_back( pt );
	}
}

void OctomapTest::loadcellinfo( )
{
	// mark free cells only if not seen occupied in this cloud

	std::string strline;
	while (std::getline(m_ifs_cellinfo, strline) )
	{
		int32_t k0, k1, k2, dummy;
		std::stringstream ss(strline);
		ss >> k0 >> k1 >> k2 >> dummy;

		OcTreeKey key(k0,k1,k2);
		point3d pt = m_octree->keyToCoord(key) ;
	}
}

void OctomapTest::save_occ_cells()
{
	loadptc() ;

	printf("\n saving occ cells \n");
	for(size_t uIdx=0; uIdx < m_PtCloud.size(); uIdx++)
	{
		point3d xyz( m_PtCloud[uIdx].x, m_PtCloud[uIdx].y, m_PtCloud[uIdx].z );
		OcTreeKey okey = m_octree->coordToKey(xyz) ;
		m_occupied_cells.insert(okey);
		m_ofs_occ_cellinfo << okey[0] << " " << okey[1] << " " << okey[0] << " "
						   << xyz.x() << " " << xyz.y() << " " << xyz.z() << std::endl;
	}
	printf("\n occ cells are saved\n");
}

void OctomapTest::save_free_cells( )
{
	std::string strline;
	uint64_t uCnt = 0;
	while (std::getline(m_ifs_cellinfo, strline) )
	{
		int32_t k0, k1, k2, dummy;
		std::stringstream ss(strline);
		ss >> k0 >> k1 >> k2 >> dummy;
		bool isFree = false ;

		OcTreeKey key(k0,k1,k2);
		printf("processing %u \n", uCnt++);
		for(KeySet::iterator it = m_occupied_cells.begin(), end=m_occupied_cells.end(); it!= end; ++it)
		{
			if( k0 == (*it)[0] && k1 == (*it)[1] && k2 == (*it)[2]  )
			{
				isFree = false;
				break;
			}
		}

		if(isFree)
		{
			// free cell
			point3d pt = m_octree->keyToCoord(key);
			m_ofs_free_cellinfo << k0 << " " << k1 << " " << k2 << " "
								<< pt.x() << " " << pt.y() << " " << pt.z() << " " << std::endl;
		}

		point3d pt = m_octree->keyToCoord(key) ;
	}
}

}

