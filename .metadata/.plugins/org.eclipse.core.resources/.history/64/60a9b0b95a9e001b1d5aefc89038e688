/*
 * FrontierDetector.cpp
 *
 *  Created on: Mar 18, 2021
 *      Author: hankm
 */


#include "../include/FrontierDetector.hpp"

namespace frontier_detector
{

FrontierDetector::FrontierDetector(const ros::NodeHandle private_nh_, const ros::NodeHandle &nh_):

m_nh_private(private_nh_),
m_nh(nh_),
m_worldFrameId("world"), m_baseFrameId("base_link_gt"),
m_globalcostmap_rows(0), m_globalcostmap_cols(0)
{

	m_nh.param("octomap_server/gridmap/num_downsamples", m_nNumPyrDownSample,1); // slide !!
	//ros::param::param("/tesse0/octomap_server/gridmap/num_downsamples", m_nNumPyrDownSample,1);
	m_nScale = pow(2, m_nNumPyrDownSample);
	//m_morph_kernel = cv::getStructuringElement( cv::MORPH_RECT, cv::Size(3,3) );
	m_targetspub = m_nh.advertise<geometry_msgs::PointStamped>("detected_points", 10);

	m_markerpub = m_nh.advertise<visualization_msgs::Marker>("detected_shapes", 10);

	//---------------------------------------------------------------
	m_mapsub = m_nh.subscribe("projected_map", 1, &FrontierDetector::gridmapCallBack, this);
	m_mapframedataSub  = m_nh.subscribe("mapframe_data", 1, &FrontierDetector::mapdataCallback, this); // kmHan
	m_globalCostmapSub = m_nh.subscribe("move_base_node/global_costmap/costmap", 1, &FrontierDetector::globalCostmapCallBack, this );
	m_poseSub		   = m_nh.subscribe("pose", 10, &FrontierDetector::robotPoseCallBack, this);

	m_makeplan_client = m_nh.serviceClient<nav_msgs::GetPlan>("move_base_node/make_plan");
	//m_move_action_client("move_base", true);

	m_frontiers_region_thr = (WEAK_COMPONENT_THR) / m_nScale ;

	m_points.header.frame_id= m_worldFrameId;
	m_points.header.stamp=ros::Time(0);
	m_points.ns= "markers";
	m_points.id = 0;
	m_points.type = m_points.POINTS;

	//Set the marker action.  Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)
	m_points.action = m_points.ADD;
	m_points.pose.orientation.w =1.0;
	m_points.scale.x=0.3;
	m_points.scale.y=0.3;

	m_points.color.r = 255.0/255.0;
	m_points.color.g = 0.0/255.0;
	m_points.color.b = 0.0/255.0;
	m_points.color.a=1.0;
	m_points.lifetime = ros::Duration();

}

FrontierDetector::~FrontierDetector()
{

}

//Norm function
float FrontierDetector::Norm(cv::Point2f x1, cv::Point2f x2)
{
	return pow(	(pow((x2.x-x1.x),2)+pow((x2.y-x1.y),2))	,0.5);
}

cv::Point2f FrontierDetector::img2grimap( cv::Point img_pt  )
{
	float fResolution=m_gridmap.info.resolution;
	float fXstart =m_gridmap.info.origin.position.x  ;
	float fYstart =m_gridmap.info.origin.position.y  ;

	float fpx = static_cast<float>(img_pt.x) - 466/2 - 45 ;
	float fpy = static_cast<float>(img_pt.y) - 528/2 ; //- 20 ;

//	ROS_WARN("%f %f %f %d %d\n", fpx, fResolution, fXstart, m_nScale, m_nNumPyrDownSample );
//	ROS_WARN("%f %f %f %d \n", fpy, fResolution, fYstart, m_nScale );
	float fgx = ( fpx * fResolution ); // + fXstart ) ;
	float fgy = ( fpy * fResolution ); // - fYstart ) ;

	return cv::Point2f( fgx, fgy );
}

//gridValue function
int FrontierDetector::gridValue(nav_msgs::OccupancyGrid &mapData, cv::Point2f Xp)
{
// Please make sure that Xp is not a downsampled point !!!!

	float resolution=mapData.info.resolution;
	float Xstartx=mapData.info.origin.position.x;
	float Xstarty=mapData.info.origin.position.y;

	float width=mapData.info.width;
	std::vector<signed char> Data=mapData.data;

	//returns grid value at "Xp" location
	//map data:  100 occupied      -1 unknown       0 free
	float indx=(  floor((Xp.y-Xstarty)/resolution)*width)+( floor((Xp.x-Xstartx)/resolution) );
//ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
//ROS_WARN("-- grid idx map size: %d %d \n", indx, Data.size() );

	int out;
	out=Data[int(indx)];
//ROS_WARN("out: %d", out);
	return out;
}

//int  FrontierDetector::costmapValue( nav_msgs::OccupancyGrid &mapData, cv::Point2f Xp )
//{
//	float Xstartx=mapData.info.origin.position.x;
//	float Xstarty=mapData.info.origin.position.y;
//
//	float width=mapData.info.width;
//	std::vector<signed char> Data=mapData.data;
//
//	//returns grid value at "Xp" location
//	//map data:  100 occupied      -1 unknown       0 free
//	float indx=(  floor((Xp.y-Xstarty)/resolution)*width)+( floor((Xp.x-Xstartx)/resolution) );
////ROS_WARN("-- (res,height,width): %f %d %d \n", resolution, mapData.info.width, mapData.info.height);
////ROS_WARN("-- grid idx map size: %d %d \n", indx, Data.size() );
//
//	int out;
//	out=Data[int(indx)];
////ROS_WARN("out: %d", out);
//	return out;
//}


// ObstacleFree function-------------------------------------
//
//char FrontierDetector::ObstacleFree(cv::Point2f xnear, cv::Point2f &xnew, nav_msgs::OccupancyGrid mapsub)
//{
//	float rez=float(mapsub.info.resolution)*.2;
//	float stepz= static_cast<float>(  static_cast<float>(ceil(Norm(xnew,xnear)))/rez  ); //int(ceil(Norm(xnew,xnear))/rez); by kmHan
//
//	char  obs=0; char unk=0;
//
//	ROS_ERROR("resolution: %f rez: %f  stepz: %f", mapsub.info.resolution, rez, stepz) ;
//
//	geometry_msgs::Point p;
//	//for (int c=0;c<stepz;c++)		// <<=== The purpose of this for-loop is ? (by kmHan)
//	{
////ROS_WARN("- xnear: %f %f xnew: %f %f \n", xnear[0], xnear[1], xnew[0], xnew[1]);
////ROS_WARN("resolution %f rez: %f \n", mapsub.info.resolution, rez);
//
//		int gridval = gridValue(mapsub,xnew) ;
//
//		if(gridval == 100) {obs=1;}	// 100 occupied
//		else if(gridval == -1)		//  -1 unknown
//		{
//			unk=1;
//		}
////		if (gridValue(mapsub,xi) ==100){     obs=1; }
////		if (gridValue(mapsub,xi) ==-1){      unk=1;	break;}
//	}
//
//	char out=0;
//	 //xnew=xi;
//
//	 if (unk==1){  out=-1;}		// unknown
//
//	 if (obs==1){  out=0;}		// occupied
//
//	 if (obs!=1 && unk!=1){   out=1;} // free
//
//	 return out;
//
// }
//


vector<cv::Point> FrontierDetector::eliminateSupriousFrontiers( vector<cv::Point> frontierCandidates)
{
	ROS_WARN("here \n");
	ROS_WARN("in func width: %d %d %f\n", m_globalcostmap.info.width, m_globalcostmap_cols, m_globalcostmap.info.resolution);

	vector<cv::Point> outFrontiers  ;
	int nRowOffset = m_globalcostmap_rows/2 ;
	int nColOffset = m_globalcostmap_cols/2 ;
	for( size_t i=0; i <= frontierCandidates.size(); i++ )
	{
		int u_ = frontierCandidates[i].x + nColOffset ;
		int v_ = frontierCandidates[i].y + nRowOffset ;
		int value = gridValue( m_globalcostmap,  cv::Point( u_, v_ )  );

		if(value > 50) // cost is near at 100 if there is an obs
			outFrontiers.push_back( cv::Point(frontierCandidates[i].x , frontierCandidates[i].y ) );
	}

	return outFrontiers ;
}

//cv::Point FrontierDetector::estimateFrontierPointPose( vector<cv::Point> frontier_contour, cv::Point frontier_point );
//{
//
//}


geometry_msgs::PoseStamped FrontierDetector::StampedPosefromSE2( float x, float y, float yaw_radian )
{
	geometry_msgs::PoseStamped outPose ;
	outPose.pose.position.x = x ;
	outPose.pose.position.y = y ;

	float c[3] = {0,};
	float s[3] = {0,};
	c[0] = cos(yaw_radian/2) ;
	c[1] = cos(0) ;
	c[2] = cos(0) ;
	s[0] = sin(yaw_radian/2) ;
	s[1] = sin(0) ;
	s[2] = sin(0) ;

	float qout[4] = {0,};
	qout[0] = c[0]*c[1]*c[2] + s[0]*s[1]*s[2];
	qout[1] = c[0]*c[1]*s[2] - s[0]*s[1]*c[2];
	qout[2] = c[0]*s[1]*c[2] + s[0]*c[1]*s[2];
	qout[3] = s[0]*c[1]*c[2] - c[0]*s[1]*s[2];

	outPose.pose.orientation.w = qout[0] ;
	outPose.pose.orientation.x = qout[1] ;
	outPose.pose.orientation.y = qout[2] ;
	outPose.pose.orientation.z = qout[3] ;

	outPose.header.frame_id = m_worldFrameId ;
	outPose.header.stamp = ros::Time::now() ;

	return outPose;
}

geometry_msgs::PoseStamped FrontierDetector::GetCurrPose ( )
{
	geometry_msgs::PoseStamped outPose ;
	outPose.header = m_robotpose.header ;
	outPose.pose.position.x = m_robotpose.pose.pose.position.x ;
	outPose.pose.position.y = m_robotpose.pose.pose.position.y ;
	outPose.pose.position.z = 0.f ;

	outPose.pose.orientation = m_robotpose.pose.pose.orientation ;

	return outPose;
}


void FrontierDetector::globalCostmapCallBack(const nav_msgs::OccupancyGrid::ConstPtr& msg)
{
	m_globalcostmap = *msg ;
	m_globalcostmap_rows = m_globalcostmap.info.height ;
	m_globalcostmap_cols = m_globalcostmap.info.width ;
}

void FrontierDetector::gridmapCallBack(const nav_msgs::OccupancyGrid::ConstPtr& msg)
{
	m_gridmap = *msg ;
}

void FrontierDetector::robotPoseCallBack( const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& msg )
{
	m_robotpose = *msg ;
	//ROS_WARN("callback pose:  %f %f \n", m_robotpose.pose.pose.position.x, m_robotpose.pose.pose.position.y);
}


void FrontierDetector::mapdataCallback(const octomap_server::mapframedata& msg )
{
	cv_bridge::CvImagePtr cv_ptr;
	cv_ptr = cv_bridge::toCvCopy( msg.image_map_2d, sensor_msgs::image_encodings::MONO8 );

	cv::Mat img ;
	img = cv_ptr->image.clone() ;

	ffpcv::FrontPropagation oFP(img); // image uchar

	oFP.update(img, cv::Point(0,0));

	oFP.extractFrontierRegion( img ) ;

	cv::Mat img_frontiers = oFP.GetFrontierContour() ;

///////////////////////////////////////////////////////////////////////////////////////////////
//  connected componentWithStat
//	stat 	--> 5 col matrix where [0],[1],[2],[3] are x, y, width, and height. [4] is the size (number of pixels)
//	centroid--> 2 col matrix where [0],[1] are the centroids (x and y coordinates)
///////////////////////////////////////////////////////////////////////////////////////////////

//	cv::Mat labelImage(img.size(), CV_32S);
//	cv::Mat stats, centroids;
//	int nLabels = cv::connectedComponentsWithStats(img_frontiers, labelImage, stats, centroids, 8);
//	std::vector<cv::Vec3b> colors(nLabels);

//    colors[0] = cv::Vec3b(0, 0, 0);//background
//    for(int label = 1; label < nLabels; ++label){
//        colors[label] = cv::Vec3b( (rand()&255), (rand()&255), (rand()&255) );
//    }
//    cv::Mat dst(img.size(), CV_8UC3);
//    for(int r = 0; r < dst.rows; ++r){
//        for(int c = 0; c < dst.cols; ++c){
//            int label = labelImage.at<int>(r, c);
//            cv::Vec3b &pixel = dst.at<cv::Vec3b>(r, c);
//            pixel = colors[label];
//         }
//     }

	cv::Mat dst;
	cvtColor(img_frontiers, dst, cv::COLOR_GRAY2BGR);
//    for(int i = 1; i < nLabels; ++i)
//    {
//        int* label = stats.ptr<int>(i);
//        if(label[4] < WEAK_COMPONENT_THR) continue;
//
//        cv::rectangle(dst, cv::Rect(label[0], label[1], label[2], label[3]), cv::Scalar(0,255,255));
//    }

// locate the most closest labeled points w.r.t the centroid pts

	vector<vector<cv::Point> > contours;
	vector<cv::Vec4i> hierarchy;
	cv::findContours( img_frontiers, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );

	// iterate through all the top-level contours,
	// draw each connected component with its own random color
	int idx = 0;
	for( ; idx >= 0; idx = hierarchy[idx][0] )
	{
		cv::Scalar color( rand()&255, rand()&255, rand()&255 );
		drawContours( dst, contours, idx, color, CV_FILLED, 8, hierarchy );
	}

	/// Get the moments
//    vector<cv::Moments> mu(contours.size() );
//    for( int i = 0; i < contours.size(); i++ )
//    	mu[i] = moments( contours[i], false );
//
//    // get cent
//    vector<cv::Point2f> mc( contours.size() );
//    for( int i = 0; i < contours.size(); i++ )
//    	mc[i] = cv::Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );

	vector<cv::Point> cents;
	for(int i=0; i < contours.size(); i++)
	{
		float fx =0, fy =0 ;
		float fcnt = 0 ;
		vector<cv::Point> contour = contours[i];
		for( int j=0; j < contour.size(); j++)
		{
			fx += static_cast<float>( contour[j].x ) ;
			fy += static_cast<float>( contour[j].y ) ;
			fcnt += 1.0;
		}
		fx = fx/fcnt ;
		fy = fy/fcnt ;

		cv::Point cent( static_cast<int>(fx),  static_cast<int>(fy) ) ;
		cents.push_back(cent);
	}

	// get closest frontier pt to each cent
	// i.e.) the final estimated frontier points
	vector<cv::Point> frontiers_cand;
	//ROS_ERROR("thr %d  \n", m_frontiers_region_thr);
	for( int i = 0; i < contours.size(); i++ )
	{
		vector<cv::Point> contour = contours[i] ;

		if(contour.size() < m_frontiers_region_thr ) // don't care about small frontier regions
			continue ;

		float fcentx = static_cast<float>(cents[i].x) ;
		float fcenty = static_cast<float>(cents[i].y) ;

		float fmindist = 1000 ;
		int nmindistidx = -1;

		for (int j=0; j < contour.size(); j++)
		{
			float fx = static_cast<float>(contour[j].x) ;
			float fy = static_cast<float>(contour[j].y) ;
			float fdist = std::sqrt( (fx - fcentx) * (fx - fcentx) + (fy - fcenty) * (fy - fcenty) );
			if(fdist < fmindist)
			{
				fmindist = fdist ;
				nmindistidx = j ;
			}
		}

		assert(nmindistidx >= 0);
		cv::Point frontier = contour[nmindistidx];
		frontiers_cand.push_back(frontier) ;
	}

//	ROS_WARN("msg: %d \n", m_globalcostmap.info.width );

	// eliminate frontier points at obtacles
	vector<cv::Point> frontiers;
//	if( m_globalcostmap.info.width > 0 )
//	{
//		frontiers = eliminateSupriousFrontiers( frontiers_cand ) ;
//	}
//	else
	{
		frontiers = frontiers_cand ;
	}

	geometry_msgs::Point p;
	// publish detected points
	for(int idx=0; idx < frontiers.size(); idx++)
	{
		cv::Point frontier = frontiers[idx] ;
//		ROS_ERROR("cent: %d %d \n",frontier.x,frontier.y);
		cv::circle(dst, frontier, 3, CV_RGB(255,0,0), 2);

		// scale then conv 2 gridmap coord
		cv::Point2f frontier_in_Gridmap = img2grimap( frontier * m_nScale );

		m_exploration_goal.header.stamp=ros::Time(0);
		m_exploration_goal.header.frame_id = m_worldFrameId;
		m_exploration_goal.point.x= frontier_in_Gridmap.x ;
		m_exploration_goal.point.y= frontier_in_Gridmap.y ;
		m_exploration_goal.point.z=0.0;

//		ROS_WARN("in image: %d %d in gridmap: %f %f ",
//				frontier.x*m_nScale, frontier.y*m_nScale, frontier_in_Gridmap.x, frontier_in_Gridmap.y );

		m_targetspub.publish(m_exploration_goal); // detected points

		p.x = m_exploration_goal.point.x ;
		p.y = m_exploration_goal.point.y ;
		p.z = 0.0 ;

		m_points.points.push_back(p);
	}

// generate a path trajectory
// call make plan service
	p = m_points.points[0];  // just for now... we need to fix it later
	nav_msgs::GetPlan::Request req;
	nav_msgs::GetPlan::Response res ;

	req.start = GetCurrPose( );
	req.goal  = StampedPosefromSE2( p.x, p.y, 0.f );
	req.goal.header.frame_id = m_worldFrameId ;
	m_makeplan_client.call( req, res );

// call actionlib
	MoveBaseClient move_action_client("move_base", true) ;

	move_base_msgs::MoveBaseGoal goal;
	goal.target_pose.header.frame_id = m_baseFrameId ;
	goal.target_pose.header.stamp = ros::Time::now() ;

	goal.target_pose.pose.position.x = req.goal.pose.position.x ;
	goal.target_pose.pose.position.y = req.goal.pose.position.y ;
	goal.target_pose.pose.orientation.w = req.goal.pose.orientation.w ;

//	m_move_action_client.sendGoal(goal);
//	m_move_action_client.waitForResult();
//
//	if(m_move_action_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
//		ROS_INFO("Hooray, the base moved 1 meter forward");
//	else
//		ROS_INFO("The base failed to move forward 1 meter for some reason");

// inspect the path
//	ROS_WARN("printing path for start(%f %f) to goal(%f %f): \n",
//			req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y );
//	for(size_t i=0; i < res.plan.poses.size(); i++)
//	{
//		ROS_WARN("goal: %f %f \n", res.plan.poses[0].pose.position.x, res.plan.poses[0].pose.position.y);
//	}

	m_markerpub.publish(m_points);
	m_points.points.clear();

//	cv::namedWindow("frontier");
//	cv::namedWindow("map");
//
//	cv::imshow("map", img);
//	cv::imshow("frontier",dst);
//
//	cv::waitKey(10);
//
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/map.png", img);
//	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_points.png", dst);
}

//void FrontierDetector::mapdataCallback(const octomap_server::mapframedata& msg )
//{
//	cv_bridge::CvImagePtr cv_ptr;
//	cv_ptr = cv_bridge::toCvCopy( msg.image_map_2d, sensor_msgs::image_encodings::MONO8 );
//
//	cv::Mat img, img_edge, img_occ_only, img_occ_dilate, img_non_occ_dialate, img_frontiers ;
//	img = cv_ptr->image.clone() ;
//
////	for(int rowidx =0; rowidx < img.rows; rowidx++)
////	{
////		for(int colidx=0; colidx < img.cols; colidx++)
////		{
////			//if( img.at<uchar>(rowidx,colidx) >= 200 )
////			ROS_WARN(" %u ", img.at<uchar>(rowidx,colidx) );
////		}
////		ROS_WARN("\n");
////	}
//
////	cv::imshow("img",img);
////	cv::waitKey(0);
//
////	ROS_WARN("img type: %d \n", img.type());  // 0 == CV_8U == uchar
//
//	// edge
//	cv::Mat imgsrc = img.clone();
//	img_edge = img.clone();
//	cv::Canny(img, img_edge, 0, 255, 3);
//	cv::threshold(img_edge, img_edge, OCCUPIED_BIN_THR, 255, cv::THRESH_BINARY);
//
//	// obstacles , walls
//	cv::threshold(img, img_occ_only, OCCUPIED_BIN_THR, 255, cv::THRESH_BINARY);
//
//	// dialate
//	//cv::morphologyEx(img_occ_only, , op, kernel, anchor, iterations, borderType, borderValue)
//	cv::dilate(img_occ_only, img_occ_dilate, m_morph_kernel, cv::Point(-1,-1),1);
//
//	// inverse image
//	cv::threshold( img_occ_dilate, img_non_occ_dialate, 1, 255, CV_THRESH_BINARY_INV);
//	img_frontiers = img_edge.mul( img_non_occ_dialate );
////	cv::erode(img_frontiers, img_frontiers, m_morph_kernel);
////	cv::dilate(img_frontiers, img_frontiers, m_morph_kernel);
//
/////////////////////////////////////////////////////////////////////////////////////////////////
////  connected componentWithStat
////	stat 	--> 5 col matrix where [0],[1],[2],[3] are x, y, width, and height. [4] is the size (number of pixels)
////	centroid--> 2 col matrix where [0],[1] are the centroids (x and y coordinates)
/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	cv::Mat labelImage(img.size(), CV_32S);
//	cv::Mat stats, centroids;
//    int nLabels = cv::connectedComponentsWithStats(img_frontiers, labelImage, stats, centroids, 8);
//    std::vector<cv::Vec3b> colors(nLabels);
////    colors[0] = cv::Vec3b(0, 0, 0);//background
////    for(int label = 1; label < nLabels; ++label){
////        colors[label] = cv::Vec3b( (rand()&255), (rand()&255), (rand()&255) );
////    }
////    cv::Mat dst(img.size(), CV_8UC3);
////    for(int r = 0; r < dst.rows; ++r){
////        for(int c = 0; c < dst.cols; ++c){
////            int label = labelImage.at<int>(r, c);
////            cv::Vec3b &pixel = dst.at<cv::Vec3b>(r, c);
////            pixel = colors[label];
////         }
////     }
//
//    cv::Mat dst;
//    cvtColor(img_frontiers, dst, cv::COLOR_GRAY2BGR);
////    for(int i = 1; i < nLabels; ++i)
////    {
////        int* label = stats.ptr<int>(i);
////        if(label[4] < WEAK_COMPONENT_THR) continue;
////
////        cv::rectangle(dst, cv::Rect(label[0], label[1], label[2], label[3]), cv::Scalar(0,255,255));
////    }
//
//// locate the most closest labeled points w.r.t the centroid pts
//
//    vector<vector<cv::Point> > contours;
//    vector<cv::Vec4i> hierarchy;
//    cv::findContours( img_frontiers, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE );
//
//    // iterate through all the top-level contours,
//    // draw each connected component with its own random color
//    int idx = 0;
//    for( ; idx >= 0; idx = hierarchy[idx][0] )
//    {
//        cv::Scalar color( rand()&255, rand()&255, rand()&255 );
//        drawContours( dst, contours, idx, color, CV_FILLED, 8, hierarchy );
//    }
//
//    /// Get the moments
////    vector<cv::Moments> mu(contours.size() );
////    for( int i = 0; i < contours.size(); i++ )
////    	mu[i] = moments( contours[i], false );
////
////    // get cent
////    vector<cv::Point2f> mc( contours.size() );
////    for( int i = 0; i < contours.size(); i++ )
////    	mc[i] = cv::Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );
//
//    vector<cv::Point> cents;
//    for(int i=0; i < contours.size(); i++)
//    {
//    	float fx =0, fy =0 ;
//    	float fcnt = 0 ;
//    	vector<cv::Point> contour = contours[i];
//    	for( int j=0; j < contour.size(); j++)
//    	{
//    		fx += static_cast<float>( contour[j].x ) ;
//    		fy += static_cast<float>( contour[j].y ) ;
//    		fcnt += 1.0;
//    	}
//    	fx = fx/fcnt ;
//    	fy = fy/fcnt ;
//
//    	cv::Point cent( static_cast<int>(fx),  static_cast<int>(fy) ) ;
//    	cents.push_back(cent);
//    }
//
//    // get closest frontier pt to each cent
//    // i.e.) the final estimated frontier points
//    vector<cv::Point> frontiers;
//    //ROS_ERROR("thr %d  \n", m_frontiers_region_thr);
//	for( int i = 0; i < contours.size(); i++ )
//	{
//		vector<cv::Point> contour = contours[i] ;
//
//		if(contour.size() < m_frontiers_region_thr ) // don't care about small frontier regions
//			continue ;
//
//		float fcentx = static_cast<float>(cents[i].x) ;
//		float fcenty = static_cast<float>(cents[i].y) ;
//
//		float fmindist = 1000 ;
//		int nmindistidx = -1;
//
//		for (int j=0; j < contour.size(); j++)
//		{
//			float fx = static_cast<float>(contour[j].x) ;
//			float fy = static_cast<float>(contour[j].y) ;
//			float fdist = std::sqrt( (fx - fcentx) * (fx - fcentx) + (fy - fcenty) * (fy - fcenty) );
//			if(fdist < fmindist)
//			{
//				fmindist = fdist ;
//				nmindistidx = j ;
//			}
//		}
//
//		assert(nmindistidx >= 0);
//		cv::Point frontier = contour[nmindistidx];
//		frontiers.push_back(frontier) ;
//	}
//
//	geometry_msgs::Point p;
//	// publish detected points
//	for(int idx=0; idx < frontiers.size(); idx++)
//	{
//		cv::Point frontier = frontiers[idx] ;
////		ROS_ERROR("cent: %d %d \n",frontier.x,frontier.y);
//		cv::circle(dst, frontier, 3, CV_RGB(255,0,0), 2);
//
//		// scale then conv 2 gridmap coord
//		cv::Point2f frontier_in_Gridmap = img2grimap( frontier * m_nScale );
//
//		m_exploration_goal.header.stamp=ros::Time(0);
//		m_exploration_goal.header.frame_id = m_worldFrameId;
//		m_exploration_goal.point.x= frontier_in_Gridmap.x ;
//		m_exploration_goal.point.y= frontier_in_Gridmap.y ;
//		m_exploration_goal.point.z=0.0;
//
//		ROS_WARN("in image: %d %d in gridmap: %f %f ",
//				frontier.x*m_nScale, frontier.y*m_nScale, frontier_in_Gridmap.x, frontier_in_Gridmap.y );
//
//		m_targetspub.publish(m_exploration_goal); // detected points
//
//		p.x = m_exploration_goal.point.x ;
//		p.y = m_exploration_goal.point.y ;
//		p.z = 0.0 ;
//
//		m_points.points.push_back(p);
//	}
//
//	m_markerpub.publish(m_points);
//	m_points.points.clear();
//
////	cv::namedWindow("frontier_detector", 1);
////	cv::namedWindow("edge",1);
////	cv::namedWindow("threshold", 1);
////	cv::namedWindow("dilate", 1);
////	cv::namedWindow("frontiers", 1);
//
////	cv::imshow("img", imgsrc);
////	cv::imshow("frontier_detector", img);
////	cv::imshow("edge",img_edge);
////	cv::imshow("threshold", img_occ_only);
////	cv::imshow("dilate", img_occ_dilate);
////	cv::imshow("frontiers", img_frontiers);
//
//    imshow( "contours frontiers", dst );
//
//	cv::waitKey(10);
//
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/img.png", img);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/edge.png", img_edge);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/threshold.png", img_occ_only);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/dilate.png", img_occ_dilate);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_contours.png", img_frontiers);
////	cv::imwrite("/home/hankm/catkin_ws/src/frontier_detector/images/frontier_points.png", dst);
//
//	return ;
//}


}

